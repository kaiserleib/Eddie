<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eddie - Guitar Tab Editor</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: #1a1a1a;
            color: #00ff00;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        .container {
            background-color: #0d0d0d;
            padding: 40px;
            border-radius: 8px;
            border: 1px solid #333;
        }

        h1 {
            text-align: center;
            margin-bottom: 15px;
            font-weight: normal;
        }

        .sample-songs-container {
            text-align: center;
            margin-bottom: 20px;
        }

        .sample-songs-container select {
            padding: 8px 16px;
            font-size: 1em;
        }

        .staffs-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .staff {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .staff-label {
            color: #666;
            font-size: 0.8em;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .waveform-select {
            background-color: #1a1a1a;
            color: #00ff00;
            border: 1px solid #444;
            padding: 2px 5px;
            font-family: inherit;
            font-size: 1em;
            border-radius: 3px;
            cursor: pointer;
        }

        .waveform-select:hover {
            border-color: #666;
        }

        .tempo-control {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #666;
        }

        .tempo-control input {
            width: 60px;
            background-color: #1a1a1a;
            color: #00ff00;
            border: 1px solid #444;
            padding: 4px 8px;
            font-family: inherit;
            font-size: 1em;
            border-radius: 3px;
            text-align: center;
        }

        .tempo-control input:hover {
            border-color: #666;
        }

        .tempo-control input:focus {
            outline: none;
            border-color: #00ff00;
        }

        .string {
            display: flex;
            align-items: center;
            gap: 0;
        }

        .string-label {
            width: 20px;
            text-align: right;
            margin-right: 10px;
            color: #666;
        }

        .note {
            width: 2ch;
            height: 1.5em;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            position: relative;
            flex-shrink: 0;
        }

        .note:hover {
            background-color: #333;
        }

        .note.selected {
            background-color: #004400;
        }

        .note.selected::after {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: #00ff00;
            animation: blink 1s step-end infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        .instructions {
            margin-top: 30px;
            color: #666;
            font-size: 0.85em;
            line-height: 1.6;
        }

        .instructions kbd {
            background-color: #333;
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid #555;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            align-items: center;
        }

        .play-btn {
            background-color: #004400;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 8px 20px;
            font-family: inherit;
            font-size: 1em;
            cursor: pointer;
            border-radius: 4px;
        }

        .play-btn:hover {
            background-color: #006600;
        }

        .play-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .loop-btn {
            background-color: transparent;
            color: #666;
            border: 1px solid #666;
            padding: 8px 16px;
            font-family: inherit;
            font-size: 1em;
            cursor: pointer;
            border-radius: 4px;
        }

        .loop-btn:hover {
            border-color: #888;
            color: #888;
        }

        .loop-btn.active {
            background-color: #004400;
            color: #00ff00;
            border-color: #00ff00;
        }

        .note.playing {
            background-color: #444400;
        }

        .sustain-row {
            display: flex;
            align-items: center;
            gap: 0;
            margin-bottom: 2px;
        }

        .sustain-toggle {
            width: 2ch;
            height: 1.2em;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            color: #333;
            font-size: 1em;
            flex-shrink: 0;
        }

        .sustain-toggle:hover {
            color: #666;
        }

        .sustain-toggle.active {
            color: #00ff00;
        }

        /* Chord mode styles */
        .chord-select-row {
            display: none;
            align-items: center;
            gap: 0;
            margin-bottom: 2px;
        }

        .chord-mode-active .chord-select-row {
            display: flex;
        }

        .chord-checkbox {
            width: 2ch;
            height: 1.2em;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            color: #666;
            font-size: 1em;
            flex-shrink: 0;
            box-sizing: border-box;
        }

        .chord-checkbox:hover {
            color: #888;
        }

        .chord-checkbox.selected {
            color: #00ff00;
            background: rgba(0, 255, 0, 0.1);
        }

        .chord-palette {
            display: none;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .chord-mode-active .chord-palette {
            display: flex;
        }

        .chord-btn {
            padding: 8px 12px;
            background: #222;
            color: #0f0;
            border: 1px solid #0f0;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9em;
            min-width: 3em;
        }

        .chord-btn:hover {
            background: #0f0;
            color: #000;
        }

        .chord-btn.minor {
            color: #0cf;
            border-color: #0cf;
        }

        .chord-btn.minor:hover {
            background: #0cf;
            color: #000;
        }

        .chord-btn.seventh {
            color: #fc0;
            border-color: #fc0;
        }

        .chord-btn.seventh:hover {
            background: #fc0;
            color: #000;
        }

        /* Mobile responsive styles */
        @media (max-width: 768px) {
            body {
                padding: 10px;
                align-items: flex-start;
            }

            .container {
                padding: 15px;
                width: 100%;
                overflow-x: auto;
            }

            h1 {
                font-size: 1.5em;
                margin-bottom: 15px;
            }

            .controls {
                flex-wrap: wrap;
                margin-bottom: 15px;
            }

            .staffs-container {
                gap: 15px;
            }

            .staff {
                min-width: max-content;
            }

            .note {
                width: 2.5ch;
                height: 2em;
                font-size: 0.9em;
            }

            .sustain-toggle, .chord-checkbox {
                width: 2.5ch;
                height: 1.5em;
            }

            .instructions {
                display: none;
            }
        }

        @media (max-width: 480px) {
            .note {
                width: 3ch;
                height: 2.2em;
            }

            .sustain-toggle, .chord-checkbox {
                width: 3ch;
                height: 1.8em;
            }

            .play-btn, .loop-btn {
                padding: 10px 16px;
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Eddie</h1>
        <div class="sample-songs-container">
            <select class="waveform-select" id="sampleSongs" onchange="loadSampleSong(this.value)">
                <option value="">Load a sample song...</option>
            </select>
            <button class="loop-btn" onclick="generateRandomSong()">Random</button>
            <button class="loop-btn" id="chromaticBtn" onclick="toggleChromatic()">7ths</button>
            <button class="loop-btn" id="soundtrackBtn" onclick="toggleSoundtrack()">Soundtrack</button>
        </div>
        <div class="controls">
            <button class="play-btn" id="playBtn" onclick="togglePlayback()">Play</button>
            <button class="loop-btn active" id="loopBtn" onclick="toggleLoop()">Loop</button>
            <button class="loop-btn" id="clearBtn" onclick="clearTab()">Clear</button>
            <button class="loop-btn" id="arpeggioBtn" onclick="toggleArpeggio()">Strum</button>
            <button class="loop-btn" id="chordModeBtn" onclick="toggleChordMode()">Chords</button>
            <button class="loop-btn active" id="guitar2Btn" onclick="toggleGuitar2()">Guitar 2</button>
            <button class="loop-btn" id="exportBtn" onclick="exportMidi()">Export MIDI</button>
            <button class="loop-btn" id="exportWavBtn" onclick="exportWav()">Export WAV</button>
            <button class="loop-btn" id="copyTabBtn" onclick="copyTabToClipboard()">Copy Tab</button>
            <label class="tempo-control">
                <span>BPM:</span>
                <input type="number" id="tempoInput" min="40" max="240" value="120" onchange="updateTempo(this.value)">
            </label>
        </div>
        <div class="chord-palette" id="chordPalette">
            <button class="chord-btn" onclick="placeChord('C')">C</button>
            <button class="chord-btn" onclick="placeChord('D')">D</button>
            <button class="chord-btn" onclick="placeChord('E')">E</button>
            <button class="chord-btn" onclick="placeChord('G')">G</button>
            <button class="chord-btn" onclick="placeChord('A')">A</button>
            <button class="chord-btn minor" onclick="placeChord('Am')">Am</button>
            <button class="chord-btn minor" onclick="placeChord('Dm')">Dm</button>
            <button class="chord-btn minor" onclick="placeChord('Em')">Em</button>
            <button class="chord-btn seventh" onclick="placeChord('A7')">A7</button>
            <button class="chord-btn seventh" onclick="placeChord('B7')">B7</button>
            <button class="chord-btn seventh" onclick="placeChord('D7')">D7</button>
            <button class="chord-btn seventh" onclick="placeChord('E7')">E7</button>
            <button class="chord-btn seventh" onclick="placeChord('G7')">G7</button>
            <button class="chord-btn" onclick="placeChord('F')">F</button>
            <button class="chord-btn minor" onclick="placeChord('Fm')">Fm</button>
            <button class="chord-btn minor" onclick="placeChord('Bm')">Bm</button>
        </div>
        <div class="staffs-container" id="staffsContainer"></div>
        <div class="instructions">
            <p><kbd>Click</kbd> to select a position</p>
            <p><kbd>0-9</kbd> Enter fret number (1-2 digits)</p>
            <p><kbd>Enter</kbd> Exit edit mode</p>
            <p><kbd>Space</kbd> / <kbd>&rarr;</kbd> Move right</p>
            <p><kbd>&larr;</kbd> Move left</p>
            <p><kbd>&uarr;</kbd> Move up</p>
            <p><kbd>&darr;</kbd> Move down</p>
        </div>
    </div>

    <script>
        const STRING_LABELS = ['e', 'B', 'G', 'D', 'A', 'E'];
        const NUM_POSITIONS = 40;
        const NUM_STAFFS = 2;
        const EN_DASH = '\u2013';

        // Binary packing for URL encoding
        // Note: 15 bits (staff:1 + string:3 + position:6 + fret:5)
        // Sustain: 7 bits (staff:1 + position:6)
        const Pack = (function() {
            const B64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
            const B64_REV = {};
            for (let i = 0; i < 64; i++) B64_REV[B64[i]] = i;

            function encode(notes, sustains) {
                // notes: [{staff, string, position, fret}, ...]
                // sustains: [{staff, position}, ...]
                const bits = [];

                // Write note count (10 bits, max 1023)
                const nc = notes.length;
                for (let i = 9; i >= 0; i--) bits.push((nc >> i) & 1);

                // Write each note (15 bits each)
                for (const n of notes) {
                    bits.push(n.staff & 1);
                    for (let i = 2; i >= 0; i--) bits.push((n.string >> i) & 1);
                    for (let i = 5; i >= 0; i--) bits.push((n.position >> i) & 1);
                    for (let i = 4; i >= 0; i--) bits.push((n.fret >> i) & 1);
                }

                // Write sustain count (8 bits, max 255)
                const sc = sustains.length;
                for (let i = 7; i >= 0; i--) bits.push((sc >> i) & 1);

                // Write each sustain (7 bits each)
                for (const s of sustains) {
                    bits.push(s.staff & 1);
                    for (let i = 5; i >= 0; i--) bits.push((s.position >> i) & 1);
                }

                // Pad to multiple of 6 for base64
                while (bits.length % 6 !== 0) bits.push(0);

                // Convert to base64
                let result = '';
                for (let i = 0; i < bits.length; i += 6) {
                    const val = (bits[i] << 5) | (bits[i+1] << 4) | (bits[i+2] << 3) |
                                (bits[i+3] << 2) | (bits[i+4] << 1) | bits[i+5];
                    result += B64[val];
                }
                return result;
            }

            function decode(str) {
                if (!str) return null;

                // Convert base64 to bits
                const bits = [];
                for (const c of str) {
                    const val = B64_REV[c];
                    if (val === undefined) return null;
                    for (let i = 5; i >= 0; i--) bits.push((val >> i) & 1);
                }

                let pos = 0;
                function readBits(n) {
                    let val = 0;
                    for (let i = 0; i < n; i++) val = (val << 1) | (bits[pos++] || 0);
                    return val;
                }

                // Read note count
                const noteCount = readBits(10);
                if (noteCount > 500) return null; // Sanity check

                // Read notes
                const notes = [];
                for (let i = 0; i < noteCount; i++) {
                    notes.push({
                        staff: readBits(1),
                        string: readBits(3),
                        position: readBits(6),
                        fret: readBits(5)
                    });
                }

                // Read sustain count
                const sustainCount = readBits(8);
                if (sustainCount > 100) return null; // Sanity check

                // Read sustains
                const sustains = [];
                for (let i = 0; i < sustainCount; i++) {
                    sustains.push({
                        staff: readBits(1),
                        position: readBits(6)
                    });
                }

                return { notes, sustains };
            }

            return { encode, decode };
        })();

        // Chord-based binary packing with predefined chord dictionary
        // Format: 'D' prefix + chord dictionary + position references + sustains
        // Chord types: 0=predefined (5 bits ID), 1=single note (8 bits), 2=custom (3+8n bits)
        const PackChord = (function() {
            const B64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
            const B64_REV = {};
            for (let i = 0; i < 64; i++) B64_REV[B64[i]] = i;

            // Predefined chord dictionary - common guitar voicings
            // Strings: 0=e, 1=B, 2=G, 3=D, 4=A, 5=E (high to low)
            const PREDEFINED = [
                // Open major chords (0-4)
                [{string:0,fret:0},{string:1,fret:1},{string:2,fret:0},{string:3,fret:2},{string:4,fret:3}],           // 0: C
                [{string:0,fret:2},{string:1,fret:3},{string:2,fret:2},{string:3,fret:0}],                             // 1: D
                [{string:0,fret:0},{string:1,fret:0},{string:2,fret:1},{string:3,fret:2},{string:4,fret:2},{string:5,fret:0}], // 2: E
                [{string:0,fret:3},{string:1,fret:0},{string:2,fret:0},{string:3,fret:0},{string:4,fret:2},{string:5,fret:3}], // 3: G
                [{string:0,fret:0},{string:1,fret:2},{string:2,fret:2},{string:3,fret:2},{string:4,fret:0}],           // 4: A
                // Open minor chords (5-7)
                [{string:0,fret:0},{string:1,fret:1},{string:2,fret:2},{string:3,fret:2},{string:4,fret:0}],           // 5: Am
                [{string:0,fret:1},{string:1,fret:3},{string:2,fret:2},{string:3,fret:0}],                             // 6: Dm
                [{string:0,fret:0},{string:1,fret:0},{string:2,fret:0},{string:3,fret:2},{string:4,fret:2},{string:5,fret:0}], // 7: Em
                // 7th chords (8-12)
                [{string:0,fret:0},{string:1,fret:2},{string:2,fret:0},{string:3,fret:2},{string:4,fret:0}],           // 8: A7
                [{string:0,fret:2},{string:1,fret:0},{string:2,fret:2},{string:3,fret:1},{string:4,fret:2}],           // 9: B7
                [{string:0,fret:2},{string:1,fret:1},{string:2,fret:2},{string:3,fret:0}],                             // 10: D7
                [{string:0,fret:0},{string:1,fret:0},{string:2,fret:1},{string:3,fret:0},{string:4,fret:2},{string:5,fret:0}], // 11: E7
                [{string:0,fret:1},{string:1,fret:0},{string:2,fret:0},{string:3,fret:0},{string:4,fret:2},{string:5,fret:3}], // 12: G7
                // Barre chords (13-16)
                [{string:0,fret:1},{string:1,fret:1},{string:2,fret:2},{string:3,fret:3},{string:4,fret:3},{string:5,fret:1}], // 13: F
                [{string:0,fret:1},{string:1,fret:1},{string:2,fret:1},{string:3,fret:3},{string:4,fret:3},{string:5,fret:1}], // 14: Fm
                [{string:0,fret:2},{string:1,fret:3},{string:2,fret:4},{string:3,fret:4},{string:4,fret:2}],           // 15: Bm
                [{string:0,fret:0},{string:1,fret:0},{string:2,fret:2},{string:3,fret:2},{string:4,fret:2},{string:5,fret:0}], // 16: Asus2
                // More common chords (17-23)
                [{string:0,fret:0},{string:1,fret:0},{string:2,fret:0},{string:3,fret:2},{string:4,fret:0}],           // 17: Am7
                [{string:0,fret:0},{string:1,fret:1},{string:2,fret:0},{string:3,fret:0},{string:4,fret:3}],           // 18: Cmaj7
                [{string:0,fret:2},{string:1,fret:2},{string:2,fret:2},{string:3,fret:0}],                             // 19: Dsus4
                [{string:0,fret:0},{string:1,fret:3},{string:2,fret:0},{string:3,fret:0},{string:4,fret:2},{string:5,fret:3}], // 20: Cadd9
                [{string:0,fret:3},{string:1,fret:3},{string:2,fret:0},{string:3,fret:0},{string:4,fret:2},{string:5,fret:3}], // 21: G/B
                [{string:0,fret:0},{string:1,fret:1},{string:2,fret:0},{string:3,fret:2},{string:4,fret:0}],           // 22: Am/E
                [{string:0,fret:2},{string:1,fret:1},{string:2,fret:2},{string:3,fret:0},{string:4,fret:0}],           // 23: Dm/A
            ];

            // Build lookup from shape key to predefined ID
            function shapeKey(notes) {
                return [...notes].sort((a, b) => a.string - b.string)
                    .map(n => n.string + ':' + n.fret).join(',');
            }
            const PREDEF_LOOKUP = {};
            PREDEFINED.forEach((shape, id) => {
                PREDEF_LOOKUP[shapeKey(shape)] = id;
            });

            function encode(notes, sustains) {
                // Group notes by staff+position into chords
                const chordsByPosition = new Map();
                for (const n of notes) {
                    const key = n.staff * 1000 + n.position;
                    if (!chordsByPosition.has(key)) {
                        chordsByPosition.set(key, { staff: n.staff, position: n.position, notes: [] });
                    }
                    chordsByPosition.get(key).notes.push({ string: n.string, fret: n.fret });
                }

                // Build chord dictionary with predefined lookup
                const shapeToId = new Map();
                const shapes = []; // Each: { type: 'predef'|'single'|'custom', data: ... }
                for (const chord of chordsByPosition.values()) {
                    const sorted = [...chord.notes].sort((a, b) => a.string - b.string);
                    const key = shapeKey(sorted);
                    if (!shapeToId.has(key)) {
                        const predefId = PREDEF_LOOKUP[key];
                        if (predefId !== undefined) {
                            shapes.push({ type: 'predef', id: predefId });
                        } else if (sorted.length === 1) {
                            shapes.push({ type: 'single', string: sorted[0].string, fret: sorted[0].fret });
                        } else {
                            shapes.push({ type: 'custom', notes: sorted });
                        }
                        shapeToId.set(key, shapes.length - 1);
                    }
                    chord.shapeId = shapeToId.get(key);
                }

                const numChords = shapes.length;
                const chordIdBits = Math.max(1, Math.ceil(Math.log2(Math.max(numChords, 2))));

                const bits = [];

                // Write chord count (5 bits, max 31)
                for (let i = 4; i >= 0; i--) bits.push((numChords >> i) & 1);

                // Write each chord shape with type prefix
                for (const shape of shapes) {
                    if (shape.type === 'predef') {
                        // Type 00 + 5-bit predefined ID = 7 bits
                        bits.push(0, 0);
                        for (let i = 4; i >= 0; i--) bits.push((shape.id >> i) & 1);
                    } else if (shape.type === 'single') {
                        // Type 01 + 3-bit string + 5-bit fret = 10 bits
                        bits.push(0, 1);
                        for (let i = 2; i >= 0; i--) bits.push((shape.string >> i) & 1);
                        for (let i = 4; i >= 0; i--) bits.push((shape.fret >> i) & 1);
                    } else {
                        // Type 1 + 3-bit count + notes = 1 + 3 + 8n bits
                        bits.push(1);
                        for (let i = 2; i >= 0; i--) bits.push((shape.notes.length >> i) & 1);
                        for (const note of shape.notes) {
                            for (let i = 2; i >= 0; i--) bits.push((note.string >> i) & 1);
                            for (let i = 4; i >= 0; i--) bits.push((note.fret >> i) & 1);
                        }
                    }
                }

                // Write position count (8 bits, max 255)
                const positions = Array.from(chordsByPosition.values());
                for (let i = 7; i >= 0; i--) bits.push((positions.length >> i) & 1);

                // Write each position reference: staff (1) + position (6) + chordId (variable)
                for (const pos of positions) {
                    bits.push(pos.staff & 1);
                    for (let i = 5; i >= 0; i--) bits.push((pos.position >> i) & 1);
                    for (let i = chordIdBits - 1; i >= 0; i--) bits.push((pos.shapeId >> i) & 1);
                }

                // Write sustain count (8 bits, max 255)
                const sc = sustains.length;
                for (let i = 7; i >= 0; i--) bits.push((sc >> i) & 1);

                // Write each sustain (7 bits each)
                for (const s of sustains) {
                    bits.push(s.staff & 1);
                    for (let i = 5; i >= 0; i--) bits.push((s.position >> i) & 1);
                }

                // Pad to multiple of 6 for base64
                while (bits.length % 6 !== 0) bits.push(0);

                // Convert to base64 with 'D' prefix (Dictionary format)
                let result = 'D';
                for (let i = 0; i < bits.length; i += 6) {
                    const val = (bits[i] << 5) | (bits[i+1] << 4) | (bits[i+2] << 3) |
                                (bits[i+3] << 2) | (bits[i+4] << 1) | bits[i+5];
                    result += B64[val];
                }
                return result;
            }

            function decode(str) {
                if (!str) return null;

                // Handle both 'D' (new dictionary) and 'C' (old chord) formats
                const prefix = str[0];
                if (prefix !== 'D' && prefix !== 'C') return null;
                const usePredefined = (prefix === 'D');
                str = str.slice(1);

                // Convert base64 to bits
                const bits = [];
                for (const c of str) {
                    const val = B64_REV[c];
                    if (val === undefined) return null;
                    for (let i = 5; i >= 0; i--) bits.push((val >> i) & 1);
                }

                let pos = 0;
                function readBits(n) {
                    let val = 0;
                    for (let i = 0; i < n; i++) val = (val << 1) | (bits[pos++] || 0);
                    return val;
                }

                // Read chord count
                const numChords = readBits(5);
                if (numChords > 31) return null;

                const chordIdBits = Math.max(1, Math.ceil(Math.log2(Math.max(numChords, 2))));

                // Read chord shapes
                const shapes = [];
                for (let i = 0; i < numChords; i++) {
                    if (usePredefined) {
                        // New format with type prefixes
                        const type1 = readBits(1);
                        if (type1 === 0) {
                            const type2 = readBits(1);
                            if (type2 === 0) {
                                // Predefined chord
                                const predefId = readBits(5);
                                shapes.push(PREDEFINED[predefId] || []);
                            } else {
                                // Single note
                                shapes.push([{ string: readBits(3), fret: readBits(5) }]);
                            }
                        } else {
                            // Custom chord
                            const noteCount = readBits(3);
                            const shape = [];
                            for (let j = 0; j < noteCount; j++) {
                                shape.push({ string: readBits(3), fret: readBits(5) });
                            }
                            shapes.push(shape);
                        }
                    } else {
                        // Old 'C' format - no type prefixes
                        const noteCount = readBits(3);
                        const shape = [];
                        for (let j = 0; j < noteCount; j++) {
                            shape.push({ string: readBits(3), fret: readBits(5) });
                        }
                        shapes.push(shape);
                    }
                }

                // Read position count
                const positionCount = readBits(8);
                if (positionCount > 255) return null;

                // Read positions and expand to notes
                const notes = [];
                for (let i = 0; i < positionCount; i++) {
                    const staff = readBits(1);
                    const position = readBits(6);
                    const shapeId = readBits(chordIdBits);
                    const shape = shapes[shapeId] || [];
                    for (const note of shape) {
                        notes.push({
                            staff,
                            string: note.string,
                            position,
                            fret: note.fret
                        });
                    }
                }

                // Read sustain count
                const sustainCount = readBits(8);
                if (sustainCount > 100) return null;

                // Read sustains
                const sustains = [];
                for (let i = 0; i < sustainCount; i++) {
                    sustains.push({
                        staff: readBits(1),
                        position: readBits(6)
                    });
                }

                return { notes, sustains };
            }

            return { encode, decode };
        })();

        let selectedStaff = null;
        let selectedString = null;
        let selectedPosition = null;
        let editMode = false;
        let pendingDigit = null;
        let guitar2Enabled = true;
        let arpeggioEnabled = false;
        let chordModeEnabled = false;
        let chromaticEnabled = false;

        // Waveform per guitar
        const guitarWaveforms = ['triangle', 'triangle'];

        // Sustain state per staff per position
        const sustainState = Array.from({ length: NUM_STAFFS }, () =>
            new Array(NUM_POSITIONS).fill(false)
        );

        // Chord selection state per staff per position
        const chordSelectState = Array.from({ length: NUM_STAFFS }, () =>
            new Array(NUM_POSITIONS).fill(false)
        );

        // Chord voicings for placement
        const CHORD_VOICINGS = {
            C:  [{string:0,fret:0},{string:1,fret:1},{string:2,fret:0},{string:3,fret:2},{string:4,fret:3}],
            D:  [{string:0,fret:2},{string:1,fret:3},{string:2,fret:2},{string:3,fret:0}],
            E:  [{string:0,fret:0},{string:1,fret:0},{string:2,fret:1},{string:3,fret:2},{string:4,fret:2},{string:5,fret:0}],
            G:  [{string:0,fret:3},{string:1,fret:0},{string:2,fret:0},{string:3,fret:0},{string:4,fret:2},{string:5,fret:3}],
            A:  [{string:0,fret:0},{string:1,fret:2},{string:2,fret:2},{string:3,fret:2},{string:4,fret:0}],
            Am: [{string:0,fret:0},{string:1,fret:1},{string:2,fret:2},{string:3,fret:2},{string:4,fret:0}],
            Dm: [{string:0,fret:1},{string:1,fret:3},{string:2,fret:2},{string:3,fret:0}],
            Em: [{string:0,fret:0},{string:1,fret:0},{string:2,fret:0},{string:3,fret:2},{string:4,fret:2},{string:5,fret:0}],
            A7: [{string:0,fret:0},{string:1,fret:2},{string:2,fret:0},{string:3,fret:2},{string:4,fret:0}],
            B7: [{string:0,fret:2},{string:1,fret:0},{string:2,fret:2},{string:3,fret:1},{string:4,fret:2}],
            D7: [{string:0,fret:2},{string:1,fret:1},{string:2,fret:2},{string:3,fret:0}],
            E7: [{string:0,fret:0},{string:1,fret:0},{string:2,fret:1},{string:3,fret:0},{string:4,fret:2},{string:5,fret:0}],
            G7: [{string:0,fret:1},{string:1,fret:0},{string:2,fret:0},{string:3,fret:0},{string:4,fret:2},{string:5,fret:3}],
            F:  [{string:0,fret:1},{string:1,fret:1},{string:2,fret:2},{string:3,fret:3},{string:4,fret:3},{string:5,fret:1}],
            Fm: [{string:0,fret:1},{string:1,fret:1},{string:2,fret:1},{string:3,fret:3},{string:4,fret:3},{string:5,fret:1}],
            Bm: [{string:0,fret:2},{string:1,fret:3},{string:2,fret:4},{string:3,fret:4},{string:4,fret:2}],
        };

        function toggleChordMode() {
            chordModeEnabled = !chordModeEnabled;
            document.getElementById('chordModeBtn').classList.toggle('active', chordModeEnabled);
            document.querySelector('.container').classList.toggle('chord-mode-active', chordModeEnabled);

            // Clear selections when exiting chord mode
            if (!chordModeEnabled) {
                clearChordSelections();
            }
        }

        function toggleChordSelect(staffIndex, position) {
            if (!chordModeEnabled) return;

            chordSelectState[staffIndex][position] = !chordSelectState[staffIndex][position];
            const checkbox = document.querySelector(`.chord-checkbox[data-staff="${staffIndex}"][data-position="${position}"]`);
            if (checkbox) {
                checkbox.classList.toggle('selected', chordSelectState[staffIndex][position]);
                checkbox.textContent = chordSelectState[staffIndex][position] ? '●' : '·';
            }
        }

        function clearChordSelections() {
            for (let staffIndex = 0; staffIndex < NUM_STAFFS; staffIndex++) {
                for (let pos = 0; pos < NUM_POSITIONS; pos++) {
                    chordSelectState[staffIndex][pos] = false;
                    const checkbox = document.querySelector(`.chord-checkbox[data-staff="${staffIndex}"][data-position="${pos}"]`);
                    if (checkbox) {
                        checkbox.classList.remove('selected');
                        checkbox.textContent = '·';
                    }
                }
            }
        }

        function placeChord(chordName) {
            const voicing = CHORD_VOICINGS[chordName];
            if (!voicing) return;

            // Place chord at all selected positions
            for (let staffIndex = 0; staffIndex < NUM_STAFFS; staffIndex++) {
                for (let pos = 0; pos < NUM_POSITIONS; pos++) {
                    if (chordSelectState[staffIndex][pos]) {
                        // Clear existing notes at this position
                        for (let s = 0; s < STRING_LABELS.length; s++) {
                            const note = getNoteElement(staffIndex, s, pos);
                            if (note) note.textContent = EN_DASH;
                        }
                        // Place chord notes
                        for (const n of voicing) {
                            const note = getNoteElement(staffIndex, n.string, pos);
                            if (note) note.textContent = n.fret;
                        }
                    }
                }
            }

            // Clear selections after placing
            clearChordSelections();

            // Save state
            saveStateToUrl();
        }

        function toggleSustain(staffIndex, position) {
            sustainState[staffIndex][position] = !sustainState[staffIndex][position];
            const toggle = document.querySelector(`.sustain-toggle[data-staff="${staffIndex}"][data-position="${position}"]`);
            if (toggle) {
                toggle.classList.toggle('active', sustainState[staffIndex][position]);
            }
            saveStateToUrl();
        }

        // Initialize all staffs
        function initStaffs() {
            const container = document.getElementById('staffsContainer');
            container.innerHTML = '';

            for (let staffIndex = 0; staffIndex < NUM_STAFFS; staffIndex++) {
                const staffWrapper = document.createElement('div');
                staffWrapper.className = 'staff';
                staffWrapper.dataset.staff = staffIndex;

                // Guitar label with waveform selector
                const staffLabel = document.createElement('div');
                staffLabel.className = 'staff-label';

                const labelText = document.createElement('span');
                labelText.textContent = `Guitar ${staffIndex + 1}`;
                staffLabel.appendChild(labelText);

                const waveformSelect = document.createElement('select');
                waveformSelect.className = 'waveform-select';
                waveformSelect.dataset.staff = staffIndex;
                ['sine', 'triangle', 'square', 'sawtooth'].forEach(waveform => {
                    const option = document.createElement('option');
                    option.value = waveform;
                    option.textContent = waveform;
                    if (waveform === guitarWaveforms[staffIndex]) {
                        option.selected = true;
                    }
                    waveformSelect.appendChild(option);
                });
                waveformSelect.addEventListener('change', (e) => {
                    guitarWaveforms[staffIndex] = e.target.value;
                });
                staffLabel.appendChild(waveformSelect);

                staffWrapper.appendChild(staffLabel);

                // Add chord select row (visible only in chord mode)
                const chordSelectRow = document.createElement('div');
                chordSelectRow.className = 'chord-select-row';

                const chordSelectLabel = document.createElement('span');
                chordSelectLabel.className = 'string-label';
                chordSelectLabel.textContent = '';
                chordSelectRow.appendChild(chordSelectLabel);

                for (let pos = 0; pos < NUM_POSITIONS; pos++) {
                    const checkbox = document.createElement('span');
                    checkbox.className = 'chord-checkbox';
                    checkbox.textContent = '·';
                    checkbox.dataset.staff = staffIndex;
                    checkbox.dataset.position = pos;
                    checkbox.addEventListener('click', () => toggleChordSelect(staffIndex, pos));
                    chordSelectRow.appendChild(checkbox);
                }
                staffWrapper.appendChild(chordSelectRow);

                // Add sustain toggle row
                const sustainRow = document.createElement('div');
                sustainRow.className = 'sustain-row';

                const sustainLabel = document.createElement('span');
                sustainLabel.className = 'string-label';
                sustainLabel.textContent = '';
                sustainRow.appendChild(sustainLabel);

                for (let pos = 0; pos < NUM_POSITIONS; pos++) {
                    const toggle = document.createElement('span');
                    toggle.className = 'sustain-toggle';
                    toggle.textContent = '~';
                    toggle.dataset.staff = staffIndex;
                    toggle.dataset.position = pos;
                    toggle.addEventListener('click', () => toggleSustain(staffIndex, pos));
                    sustainRow.appendChild(toggle);
                }
                staffWrapper.appendChild(sustainRow);

                STRING_LABELS.forEach((label, stringIndex) => {
                    const stringRow = document.createElement('div');
                    stringRow.className = 'string';

                    const labelEl = document.createElement('span');
                    labelEl.className = 'string-label';
                    labelEl.textContent = label;
                    stringRow.appendChild(labelEl);

                    for (let pos = 0; pos < NUM_POSITIONS; pos++) {
                        const note = document.createElement('span');
                        note.className = 'note';
                        note.textContent = EN_DASH;
                        note.dataset.staff = staffIndex;
                        note.dataset.string = stringIndex;
                        note.dataset.position = pos;
                        note.addEventListener('click', (e) => {
                            if (note.dataset.longPressTriggered) {
                                delete note.dataset.longPressTriggered;
                                return;
                            }
                            handleNoteClick(staffIndex, stringIndex, pos);
                        });

                        // Long press to delete (mobile)
                        let longPressTimer;
                        note.addEventListener('touchstart', (e) => {
                            longPressTimer = setTimeout(() => {
                                note.dataset.longPressTriggered = 'true';
                                deleteNoteAt(staffIndex, stringIndex, pos);
                            }, 500);
                        }, { passive: true });
                        note.addEventListener('touchend', () => clearTimeout(longPressTimer));
                        note.addEventListener('touchcancel', () => clearTimeout(longPressTimer));
                        note.addEventListener('touchmove', () => clearTimeout(longPressTimer));

                        stringRow.appendChild(note);
                    }

                    staffWrapper.appendChild(stringRow);
                });

                container.appendChild(staffWrapper);
            }
        }

        const MAX_FRET = 24;

        function getNoteElement(staffIndex, stringIndex, position) {
            return document.querySelector(`.note[data-staff="${staffIndex}"][data-string="${stringIndex}"][data-position="${position}"]`);
        }

        function clearSelection() {
            document.querySelectorAll('.note.selected').forEach(el => el.classList.remove('selected'));
        }

        function handleNoteClick(staffIndex, stringIndex, position) {
            // If this note is already selected, increment the fret number
            if (selectedStaff === staffIndex && selectedString === stringIndex && selectedPosition === position) {
                incrementFret();
            } else {
                selectNote(staffIndex, stringIndex, position);
            }
        }

        function incrementFret() {
            if (selectedStaff === null || selectedString === null || selectedPosition === null) return;

            const note = getNoteElement(selectedStaff, selectedString, selectedPosition);
            if (!note) return;

            const currentValue = note.textContent;
            let newFret;

            if (currentValue === EN_DASH) {
                newFret = 0;
            } else {
                const currentFret = parseInt(currentValue);
                if (isNaN(currentFret)) {
                    newFret = 0;
                } else if (currentFret >= MAX_FRET) {
                    newFret = EN_DASH; // Wrap back to empty
                } else {
                    newFret = currentFret + 1;
                }
            }

            note.textContent = newFret;
            saveStateToUrl();
        }

        function deleteNoteAt(staffIndex, stringIndex, position) {
            const note = getNoteElement(staffIndex, stringIndex, position);
            if (!note) return;
            note.textContent = EN_DASH;
            saveStateToUrl();
        }

        function selectNote(staffIndex, stringIndex, position) {
            // Bounds checking
            if (staffIndex < 0 || staffIndex >= NUM_STAFFS) return;
            if (stringIndex < 0 || stringIndex >= STRING_LABELS.length) return;
            if (position < 0 || position >= NUM_POSITIONS) return;

            clearSelection();
            selectedStaff = staffIndex;
            selectedString = stringIndex;
            selectedPosition = position;
            editMode = true;
            pendingDigit = null;

            const note = getNoteElement(staffIndex, stringIndex, position);
            if (note) {
                note.classList.add('selected');
            }
        }

        function exitEditMode() {
            clearSelection();
            selectedStaff = null;
            selectedString = null;
            selectedPosition = null;
            editMode = false;
            pendingDigit = null;
        }

        function setNoteValue(value) {
            if (selectedStaff === null || selectedString === null || selectedPosition === null) return;

            const note = getNoteElement(selectedStaff, selectedString, selectedPosition);
            if (note) {
                note.textContent = value;
                saveStateToUrl();
            }
        }

        // Serialize state to URL using binary packing
        function saveStateToUrl() {
            const notes = [];
            const sustains = [];

            // Collect all notes
            for (let staffIndex = 0; staffIndex < NUM_STAFFS; staffIndex++) {
                document.querySelectorAll(`.note[data-staff="${staffIndex}"]`).forEach(note => {
                    const value = note.textContent;
                    if (value !== EN_DASH) {
                        notes.push({
                            staff: staffIndex,
                            string: parseInt(note.dataset.string),
                            position: parseInt(note.dataset.position),
                            fret: parseInt(value)
                        });
                    }
                });
            }

            // Collect sustain toggles
            for (let staffIndex = 0; staffIndex < NUM_STAFFS; staffIndex++) {
                sustainState[staffIndex].forEach((active, pos) => {
                    if (active) {
                        sustains.push({ staff: staffIndex, position: pos });
                    }
                });
            }

            // Only save if there's actual content
            if (notes.length > 0 || sustains.length > 0) {
                // Try both encodings and use the shorter one
                const packedNote = Pack.encode(notes, sustains);
                const packedChord = PackChord.encode(notes, sustains);
                const packed = packedChord.length < packedNote.length ? packedChord : packedNote;
                history.replaceState(null, '', '#' + packed);
            } else {
                history.replaceState(null, '', window.location.pathname);
            }
        }

        // Restore state from URL
        function loadStateFromUrl() {
            const hash = window.location.hash.slice(1);
            if (!hash) return;

            try {
                // Try chord-packed format first (starts with 'C')
                const packedChord = PackChord.decode(hash);
                if (packedChord) {
                    // Load notes
                    for (const n of packedChord.notes) {
                        const note = getNoteElement(n.staff, n.string, n.position);
                        if (note) note.textContent = n.fret;
                    }
                    // Load sustains
                    for (const s of packedChord.sustains) {
                        if (s.staff < NUM_STAFFS && s.position < NUM_POSITIONS) {
                            sustainState[s.staff][s.position] = true;
                            const toggle = document.querySelector(`.sustain-toggle[data-staff="${s.staff}"][data-position="${s.position}"]`);
                            if (toggle) toggle.classList.add('active');
                        }
                    }
                    return;
                }

                // Try note-by-note binary packed format
                const packed = Pack.decode(hash);
                if (packed) {
                    // Load notes
                    for (const n of packed.notes) {
                        const note = getNoteElement(n.staff, n.string, n.position);
                        if (note) note.textContent = n.fret;
                    }
                    // Load sustains
                    for (const s of packed.sustains) {
                        if (s.staff < NUM_STAFFS && s.position < NUM_POSITIONS) {
                            sustainState[s.staff][s.position] = true;
                            const toggle = document.querySelector(`.sustain-toggle[data-staff="${s.staff}"][data-position="${s.position}"]`);
                            if (toggle) toggle.classList.add('active');
                        }
                    }
                    return;
                }

                // Fallback for legacy URL-encoded format
                const state = decodeURIComponent(hash);
                const mainParts = state.split(';');

                // Parse notes (first part before ;)
                if (mainParts[0]) {
                    const staffNoteParts = mainParts[0].split('|');
                    staffNoteParts.forEach((staffNotes, staffIndex) => {
                        if (staffIndex >= NUM_STAFFS || !staffNotes) return;
                        const notes = staffNotes.split(',');
                        notes.forEach(noteData => {
                            if (!noteData) return;
                            const [s, p, value] = noteData.split('.');
                            const note = getNoteElement(staffIndex, parseInt(s), parseInt(p));
                            if (note && value) {
                                note.textContent = value;
                            }
                        });
                    });
                }

                // Parse sustain (second part after ;)
                if (mainParts[1]) {
                    const sustainParts = mainParts[1].split('|');
                    sustainParts.forEach(part => {
                        const match = part.match(/^s(\d+):(.*)$/);
                        if (match) {
                            const staffIndex = parseInt(match[1]);
                            if (staffIndex >= NUM_STAFFS) return;
                            const positions = match[2].split(',');
                            positions.forEach(pos => {
                                const p = parseInt(pos);
                                if (!isNaN(p) && p >= 0 && p < NUM_POSITIONS) {
                                    sustainState[staffIndex][p] = true;
                                    const toggle = document.querySelector(`.sustain-toggle[data-staff="${staffIndex}"][data-position="${p}"]`);
                                    if (toggle) toggle.classList.add('active');
                                }
                            });
                        }
                    });
                }
            } catch (e) {
                console.error('Failed to load state from URL:', e);
            }
        }

        function moveRight() {
            if (selectedStaff === null || selectedString === null || selectedPosition === null) return;
            if (selectedPosition < NUM_POSITIONS - 1) {
                selectNote(selectedStaff, selectedString, selectedPosition + 1);
            }
        }

        function moveLeft() {
            if (selectedStaff === null || selectedString === null || selectedPosition === null) return;
            if (selectedPosition > 0) {
                selectNote(selectedStaff, selectedString, selectedPosition - 1);
            }
        }

        function moveUp() {
            if (selectedStaff === null || selectedString === null || selectedPosition === null) return;
            if (selectedString > 0) {
                selectNote(selectedStaff, selectedString - 1, selectedPosition);
            } else if (selectedStaff > 0) {
                // Move to previous staff, last string
                selectNote(selectedStaff - 1, STRING_LABELS.length - 1, selectedPosition);
            }
        }

        function moveDown() {
            if (selectedStaff === null || selectedString === null || selectedPosition === null) return;
            if (selectedString < STRING_LABELS.length - 1) {
                selectNote(selectedStaff, selectedString + 1, selectedPosition);
            } else if (selectedStaff < NUM_STAFFS - 1) {
                // Move to next staff, first string
                selectNote(selectedStaff + 1, 0, selectedPosition);
            }
        }

        document.addEventListener('keydown', (e) => {
            if (!editMode) return;

            // Handle digit input
            if (e.key >= '0' && e.key <= '9') {
                e.preventDefault();

                if (pendingDigit !== null) {
                    // Second digit - create two-digit fret number
                    const fret = pendingDigit * 10 + parseInt(e.key);
                    setNoteValue(fret.toString());
                    pendingDigit = null;
                    moveRight();
                } else {
                    // First digit - set it and wait for potential second digit
                    pendingDigit = parseInt(e.key);
                    setNoteValue(e.key);
                }
                return;
            }

            // Any non-digit key commits the pending digit
            if (pendingDigit !== null) {
                pendingDigit = null;
            }

            switch (e.key) {
                case 'Enter':
                    e.preventDefault();
                    exitEditMode();
                    break;
                case ' ':
                case 'ArrowRight':
                    e.preventDefault();
                    moveRight();
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    moveLeft();
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    moveUp();
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    moveDown();
                    break;
                case 'Escape':
                    e.preventDefault();
                    exitEditMode();
                    break;
                case 'Backspace':
                case '-':
                    e.preventDefault();
                    setNoteValue(EN_DASH);
                    break;
            }
        });

        // Click outside to deselect
        document.addEventListener('click', (e) => {
            if (!e.target.classList.contains('note')) {
                exitEditMode();
            }
        });

        // ========== PLAYBACK ==========

        // Standard tuning open string frequencies (high e to low E)
        const STRING_FREQUENCIES = [
            329.63,  // e4
            246.94,  // B3
            196.00,  // G3
            146.83,  // D3
            110.00,  // A2
            82.41    // E2
        ];

        let audioCtx = null;
        let isPlaying = false;
        let loopEnabled = true;
        let playbackTimeout = null;
        let soundtrackEnabled = false;
        let soundtrackPlayCount = 0;
        let soundtrackTargetCount = 0;

        // Track active sustained notes per staff per string
        const activeNotes = Array.from({ length: NUM_STAFFS }, () =>
            new Array(STRING_LABELS.length).fill(null)
        );

        let tempoBpm = 120;

        function getQuarterNoteMs() {
            return 60000 / tempoBpm;
        }

        function updateTempo(value) {
            const bpm = parseInt(value);
            if (!isNaN(bpm) && bpm >= 40 && bpm <= 240) {
                tempoBpm = bpm;
            }
        }

        function toggleLoop() {
            loopEnabled = !loopEnabled;
            document.getElementById('loopBtn').classList.toggle('active', loopEnabled);
        }

        function toggleGuitar2() {
            guitar2Enabled = !guitar2Enabled;
            document.getElementById('guitar2Btn').classList.toggle('active', guitar2Enabled);
            const guitar2Staff = document.querySelector('.staff[data-staff="1"]');
            if (guitar2Staff) {
                guitar2Staff.style.display = guitar2Enabled ? '' : 'none';
            }
        }

        function toggleArpeggio() {
            arpeggioEnabled = !arpeggioEnabled;
            document.getElementById('arpeggioBtn').classList.toggle('active', arpeggioEnabled);
        }

        function toggleChromatic() {
            chromaticEnabled = !chromaticEnabled;
            document.getElementById('chromaticBtn').classList.toggle('active', chromaticEnabled);
        }

        function toggleSoundtrack() {
            soundtrackEnabled = !soundtrackEnabled;
            document.getElementById('soundtrackBtn').classList.toggle('active', soundtrackEnabled);
            if (soundtrackEnabled) {
                // Initialize soundtrack mode
                soundtrackPlayCount = 0;
                soundtrackTargetCount = Math.floor(Math.random() * 4) + 2; // 2-5 plays
                // Ensure loop is enabled for soundtrack mode
                if (!loopEnabled) {
                    loopEnabled = true;
                    document.getElementById('loopBtn').classList.add('active');
                }
            }
        }

        function clearTab() {
            stopPlayback();
            document.querySelectorAll('.note').forEach(note => {
                note.textContent = EN_DASH;
            });
            // Clear sustain state for all staffs
            for (let staffIndex = 0; staffIndex < NUM_STAFFS; staffIndex++) {
                for (let i = 0; i < NUM_POSITIONS; i++) {
                    sustainState[staffIndex][i] = false;
                }
            }
            document.querySelectorAll('.sustain-toggle').forEach(toggle => {
                toggle.classList.remove('active');
            });
            saveStateToUrl();
        }

        function getFrequency(stringIndex, fret) {
            const openFreq = STRING_FREQUENCIES[stringIndex];
            // Each fret is a semitone higher: freq * 2^(fret/12)
            return openFreq * Math.pow(2, fret / 12);
        }

        // Gain adjustments to normalize perceived volume across waveforms
        const WAVEFORM_GAINS = {
            sine: 0.35,
            triangle: 0.3,
            square: 0.15,
            sawtooth: 0.2
        };

        function playNote(frequency, duration, sustain = false, waveform = 'triangle') {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = waveform;
            oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);

            const baseGain = WAVEFORM_GAINS[waveform] || 0.3;
            const now = audioCtx.currentTime;
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(baseGain, now + 0.01);

            oscillator.start(now);

            if (sustain) {
                // Sustain: hold at slightly reduced gain, will be stopped manually
                gainNode.gain.setValueAtTime(baseGain * 0.8, now + 0.02);
            } else {
                // Quick attack, gradual decay for plucked string feel
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration / 1000);
                oscillator.stop(now + duration / 1000);
            }

            // Return a stop function for sustained notes
            let stopped = false;
            return {
                stop: () => {
                    if (stopped) return;
                    stopped = true;
                    try {
                        const stopTime = audioCtx.currentTime;
                        gainNode.gain.cancelScheduledValues(stopTime);
                        gainNode.gain.setValueAtTime(Math.max(gainNode.gain.value, 0.01), stopTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, stopTime + 0.05);
                        oscillator.stop(stopTime + 0.06);
                    } catch (e) {
                        // Oscillator may already be stopped
                    }
                }
            };
        }

        function stopActiveNote(staffIndex, stringIndex) {
            if (activeNotes[staffIndex][stringIndex]) {
                try {
                    activeNotes[staffIndex][stringIndex].stop();
                } catch (e) {
                    // Already stopped
                }
                activeNotes[staffIndex][stringIndex] = null;
            }
        }

        function stopAllActiveNotesForStaff(staffIndex) {
            for (let i = 0; i < STRING_LABELS.length; i++) {
                stopActiveNote(staffIndex, i);
            }
        }

        function stopAllActiveNotes() {
            for (let staffIndex = 0; staffIndex < NUM_STAFFS; staffIndex++) {
                stopAllActiveNotesForStaff(staffIndex);
            }
        }

        function clearPlayhead() {
            document.querySelectorAll('.note.playing').forEach(el => el.classList.remove('playing'));
        }

        function findLastNotePosition() {
            let lastPos = -1;
            document.querySelectorAll('.note').forEach(note => {
                // Skip Guitar 2 notes if disabled
                if (note.dataset.staff === '1' && !guitar2Enabled) return;

                if (note.textContent !== EN_DASH) {
                    const pos = parseInt(note.dataset.position);
                    if (pos > lastPos) lastPos = pos;
                }
            });
            return lastPos;
        }

        function playPosition(position, lastPosition) {
            if (!isPlaying) return;

            clearPlayhead();

            // If we've passed the last note, either loop or stop
            if (position > lastPosition) {
                stopAllActiveNotes();
                if (loopEnabled) {
                    // Handle soundtrack mode
                    if (soundtrackEnabled) {
                        soundtrackPlayCount++;
                        if (soundtrackPlayCount >= soundtrackTargetCount) {
                            // Generate new song (resets counter internally)
                            generateRandomSong();
                            // Start playing the new song
                            const newLastPosition = findLastNotePosition();
                            playPosition(0, newLastPosition);
                            return;
                        }
                    }
                    playPosition(0, lastPosition);
                    return;
                } else {
                    stopPlayback();
                    return;
                }
            }

            // Play notes from all staffs at this position
            for (let staffIndex = 0; staffIndex < NUM_STAFFS; staffIndex++) {
                // Skip Guitar 2 if disabled
                if (staffIndex === 1 && !guitar2Enabled) continue;

                const isSustained = sustainState[staffIndex][position];

                // Check if this position has any notes on this staff
                let hasNotesAtPosition = false;
                for (let s = 0; s < STRING_LABELS.length; s++) {
                    const note = getNoteElement(staffIndex, s, position);
                    if (note && note.textContent !== EN_DASH) {
                        hasNotesAtPosition = true;
                        break;
                    }
                }

                // If this position has notes and sustain is OFF, stop all sustained notes for this staff
                if (hasNotesAtPosition && !isSustained) {
                    stopAllActiveNotesForStaff(staffIndex);
                }

                // Strum from low E (string 5) to high e (string 0) for realistic guitar sound
                const strumDelay = arpeggioEnabled ? 20 : 0; // ms between strings
                for (let i = 0; i < STRING_LABELS.length; i++) {
                    const s = 5 - i; // Start from low E (string 5) and go up
                    const note = getNoteElement(staffIndex, s, position);
                    if (note) {
                        note.classList.add('playing');
                        const value = note.textContent;
                        if (value !== EN_DASH) {
                            const fret = parseInt(value);
                            if (!isNaN(fret)) {
                                // Schedule note with strum offset
                                const delay = i * strumDelay;
                                setTimeout(() => {
                                    if (!isPlaying) return;
                                    // Stop any previously sustained note on this string
                                    stopActiveNote(staffIndex, s);

                                    const waveform = guitarWaveforms[staffIndex];
                                    const noteHandle = playNote(getFrequency(s, fret), getQuarterNoteMs() * 0.9, isSustained, waveform);
                                    if (isSustained) {
                                        activeNotes[staffIndex][s] = noteHandle;
                                    }
                                }, delay);
                            }
                        }
                    }
                }
            }

            // Schedule next position
            playbackTimeout = setTimeout(() => {
                playPosition(position + 1, lastPosition);
            }, getQuarterNoteMs());
        }

        function startPlayback() {
            const lastPosition = findLastNotePosition();
            if (lastPosition < 0) return; // No notes to play

            isPlaying = true;
            document.getElementById('playBtn').textContent = 'Stop';
            exitEditMode();
            playPosition(0, lastPosition);
        }

        function stopPlayback() {
            isPlaying = false;
            if (playbackTimeout) {
                clearTimeout(playbackTimeout);
                playbackTimeout = null;
            }
            stopAllActiveNotes();
            clearPlayhead();
            document.getElementById('playBtn').textContent = 'Play';
        }

        function togglePlayback() {
            if (isPlaying) {
                stopPlayback();
            } else {
                startPlayback();
            }
        }

        // ========== MIDI EXPORT ==========

        // MIDI note numbers for open strings (standard tuning)
        const STRING_MIDI_NOTES = [64, 59, 55, 50, 45, 40]; // e4, B3, G3, D3, A2, E2

        function exportMidi() {
            const lastPos = findLastNotePosition();
            if (lastPos < 0) {
                alert('No notes to export!');
                return;
            }

            // Collect all notes from enabled staffs
            const ticksPerBeat = 480;
            const tracks = [];

            for (let staffIndex = 0; staffIndex < NUM_STAFFS; staffIndex++) {
                if (staffIndex === 1 && !guitar2Enabled) continue;

                const events = [];

                for (let pos = 0; pos <= lastPos; pos++) {
                    const isSustained = sustainState[staffIndex][pos];
                    const noteDuration = isSustained ? ticksPerBeat * 4 : ticksPerBeat; // Sustain = whole note, normal = quarter

                    for (let s = 0; s < STRING_LABELS.length; s++) {
                        const note = getNoteElement(staffIndex, s, pos);
                        if (note && note.textContent !== EN_DASH) {
                            const fret = parseInt(note.textContent);
                            if (!isNaN(fret)) {
                                const midiNote = STRING_MIDI_NOTES[s] + fret;
                                const startTick = pos * ticksPerBeat;
                                events.push({ type: 'noteOn', tick: startTick, note: midiNote, velocity: 80 });
                                events.push({ type: 'noteOff', tick: startTick + noteDuration, note: midiNote, velocity: 0 });
                            }
                        }
                    }
                }

                if (events.length > 0) {
                    tracks.push(events);
                }
            }

            if (tracks.length === 0) {
                alert('No notes to export!');
                return;
            }

            const midiData = buildMidiFile(tracks, ticksPerBeat);
            downloadMidi(midiData, 'eddie-tab.mid');
        }

        function buildMidiFile(tracks, ticksPerBeat) {
            const bytes = [];

            // Header chunk
            writeString(bytes, 'MThd');
            writeUint32(bytes, 6); // Header length
            writeUint16(bytes, 1); // Format 1 (multiple tracks)
            writeUint16(bytes, tracks.length + 1); // Number of tracks (+1 for tempo track)
            writeUint16(bytes, ticksPerBeat); // Ticks per quarter note

            // Tempo track
            const tempoTrack = [];
            // Tempo in microseconds per beat = 60,000,000 / BPM
            const microsecondsPerBeat = Math.round(60000000 / tempoBpm);
            tempoTrack.push(0x00, 0xFF, 0x51, 0x03,
                (microsecondsPerBeat >> 16) & 0xFF,
                (microsecondsPerBeat >> 8) & 0xFF,
                microsecondsPerBeat & 0xFF);
            // End of track
            tempoTrack.push(0x00, 0xFF, 0x2F, 0x00);

            writeString(bytes, 'MTrk');
            writeUint32(bytes, tempoTrack.length);
            bytes.push(...tempoTrack);

            // Note tracks
            tracks.forEach((events, trackIndex) => {
                const trackBytes = [];

                // Sort events by tick, then noteOff before noteOn for same tick
                events.sort((a, b) => {
                    if (a.tick !== b.tick) return a.tick - b.tick;
                    if (a.type === 'noteOff' && b.type === 'noteOn') return -1;
                    if (a.type === 'noteOn' && b.type === 'noteOff') return 1;
                    return 0;
                });

                // Track name
                const trackName = `Guitar ${trackIndex + 1}`;
                writeVarLen(trackBytes, 0);
                trackBytes.push(0xFF, 0x03, trackName.length);
                for (let i = 0; i < trackName.length; i++) {
                    trackBytes.push(trackName.charCodeAt(i));
                }

                // Program change to acoustic guitar (channel = trackIndex, program 25)
                writeVarLen(trackBytes, 0);
                trackBytes.push(0xC0 | trackIndex, 25);

                let lastTick = 0;
                events.forEach(event => {
                    const delta = event.tick - lastTick;
                    writeVarLen(trackBytes, delta);

                    if (event.type === 'noteOn') {
                        trackBytes.push(0x90 | trackIndex, event.note, event.velocity);
                    } else {
                        trackBytes.push(0x80 | trackIndex, event.note, 0);
                    }
                    lastTick = event.tick;
                });

                // End of track
                writeVarLen(trackBytes, 0);
                trackBytes.push(0xFF, 0x2F, 0x00);

                writeString(bytes, 'MTrk');
                writeUint32(bytes, trackBytes.length);
                bytes.push(...trackBytes);
            });

            return new Uint8Array(bytes);
        }

        function writeString(bytes, str) {
            for (let i = 0; i < str.length; i++) {
                bytes.push(str.charCodeAt(i));
            }
        }

        function writeUint32(bytes, value) {
            bytes.push((value >> 24) & 0xFF);
            bytes.push((value >> 16) & 0xFF);
            bytes.push((value >> 8) & 0xFF);
            bytes.push(value & 0xFF);
        }

        function writeUint16(bytes, value) {
            bytes.push((value >> 8) & 0xFF);
            bytes.push(value & 0xFF);
        }

        function writeVarLen(bytes, value) {
            const buffer = [];
            buffer.push(value & 0x7F);
            value >>= 7;
            while (value > 0) {
                buffer.push((value & 0x7F) | 0x80);
                value >>= 7;
            }
            for (let i = buffer.length - 1; i >= 0; i--) {
                bytes.push(buffer[i]);
            }
        }

        function downloadMidi(data, filename) {
            const blob = new Blob([data], { type: 'audio/midi' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // ========== WAV EXPORT ==========

        async function exportWav() {
            const lastPos = findLastNotePosition();
            if (lastPos < 0) {
                alert('No notes to export!');
                return;
            }

            const quarterNoteMs = getQuarterNoteMs();
            const sampleRate = 44100;
            const duration = ((lastPos + 1) * quarterNoteMs) / 1000 + 1; // Add 1 second for decay
            const offlineCtx = new OfflineAudioContext(2, sampleRate * duration, sampleRate);

            // Render all notes
            for (let staffIndex = 0; staffIndex < NUM_STAFFS; staffIndex++) {
                if (staffIndex === 1 && !guitar2Enabled) continue;

                for (let pos = 0; pos <= lastPos; pos++) {
                    const isSustained = sustainState[staffIndex][pos];
                    const noteDuration = isSustained ? quarterNoteMs * 4 : quarterNoteMs * 0.9;
                    const startTime = (pos * quarterNoteMs) / 1000;

                    for (let s = 0; s < STRING_LABELS.length; s++) {
                        const note = getNoteElement(staffIndex, s, pos);
                        if (note && note.textContent !== EN_DASH) {
                            const fret = parseInt(note.textContent);
                            if (!isNaN(fret)) {
                                const frequency = getFrequency(s, fret);
                                const waveform = guitarWaveforms[staffIndex];
                                renderNoteToContext(offlineCtx, frequency, startTime, noteDuration / 1000, waveform);
                            }
                        }
                    }
                }
            }

            // Render and download
            const renderedBuffer = await offlineCtx.startRendering();
            const wavData = audioBufferToWav(renderedBuffer);
            downloadWav(wavData, 'eddie-tab.wav');
        }

        function generateTabText(staffIndex) {
            const lastPos = findLastNotePosition();
            if (lastPos < 0) return null;

            const lines = STRING_LABELS.map(label => label + '|');

            for (let pos = 0; pos <= lastPos; pos++) {
                for (let s = 0; s < STRING_LABELS.length; s++) {
                    const note = getNoteElement(staffIndex, s, pos);
                    const value = note ? note.textContent : EN_DASH;
                    // Pad to 3 chars for alignment (handles frets 0-24)
                    if (value === EN_DASH) {
                        lines[s] += '---';
                    } else {
                        lines[s] += value.padStart(2, '-') + '-';
                    }
                }
            }

            // Add closing bar
            for (let s = 0; s < STRING_LABELS.length; s++) {
                lines[s] += '|';
            }

            return lines.join('\n');
        }

        async function copyTabToClipboard() {
            const tabs = [];

            // Guitar 1
            const tab1 = generateTabText(0);
            if (tab1) {
                tabs.push('Guitar 1:\n' + tab1);
            }

            // Guitar 2 (if enabled and has notes)
            if (guitar2Enabled) {
                const tab2 = generateTabText(1);
                if (tab2) {
                    tabs.push('Guitar 2:\n' + tab2);
                }
            }

            if (tabs.length === 0) {
                alert('No notes to copy!');
                return;
            }

            const text = tabs.join('\n\n');

            try {
                await navigator.clipboard.writeText(text);
                // Brief visual feedback
                const btn = document.getElementById('copyTabBtn');
                const original = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = original, 1500);
            } catch (e) {
                alert('Failed to copy to clipboard');
            }
        }

        function renderNoteToContext(ctx, frequency, startTime, duration, waveform) {
            const oscillator = ctx.createOscillator();
            const gainNode = ctx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(ctx.destination);

            oscillator.type = waveform;
            oscillator.frequency.setValueAtTime(frequency, startTime);

            const baseGain = WAVEFORM_GAINS[waveform] || 0.3;
            gainNode.gain.setValueAtTime(0, startTime);
            gainNode.gain.linearRampToValueAtTime(baseGain, startTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + duration);

            oscillator.start(startTime);
            oscillator.stop(startTime + duration);
        }

        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;

            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;

            const samples = buffer.length;
            const dataSize = samples * blockAlign;
            const bufferSize = 44 + dataSize;

            const arrayBuffer = new ArrayBuffer(bufferSize);
            const view = new DataView(arrayBuffer);

            // WAV header
            writeWavString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeWavString(view, 8, 'WAVE');
            writeWavString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); // fmt chunk size
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeWavString(view, 36, 'data');
            view.setUint32(40, dataSize, true);

            // Interleave channels and write samples
            const channelData = [];
            for (let ch = 0; ch < numChannels; ch++) {
                channelData.push(buffer.getChannelData(ch));
            }

            let offset = 44;
            for (let i = 0; i < samples; i++) {
                for (let ch = 0; ch < numChannels; ch++) {
                    let sample = channelData[ch][i];
                    sample = Math.max(-1, Math.min(1, sample));
                    sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                    view.setInt16(offset, sample, true);
                    offset += 2;
                }
            }

            return new Uint8Array(arrayBuffer);
        }

        function writeWavString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        function downloadWav(data, filename) {
            const blob = new Blob([data], { type: 'audio/wav' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // ========== SAMPLE SONGS ==========

        async function initSampleSongs() {
            const select = document.getElementById('sampleSongs');
            try {
                const response = await fetch('songs.json');
                const songs = await response.json();
                songs.forEach(song => {
                    const option = document.createElement('option');
                    option.value = song.hash;
                    option.textContent = song.name;
                    select.appendChild(option);
                });
            } catch (e) {
                // songs.json not available (e.g., file:// protocol)
                console.log('Could not load songs.json:', e.message);
            }
        }

        // Random song generator using music theory
        function generateRandomSong() {
            // Reset soundtrack counter when generating a new song
            if (soundtrackEnabled) {
                soundtrackPlayCount = 0;
                soundtrackTargetCount = Math.floor(Math.random() * 4) + 2; // 2-5 plays
            }

            // Chord voicings (matching predefined chord IDs)
            // Strings: 0=e, 1=B, 2=G, 3=D, 4=A, 5=E
            const CHORDS = {
                C:  [{string:0,fret:0},{string:1,fret:1},{string:2,fret:0},{string:3,fret:2},{string:4,fret:3}],
                D:  [{string:0,fret:2},{string:1,fret:3},{string:2,fret:2},{string:3,fret:0}],
                E:  [{string:0,fret:0},{string:1,fret:0},{string:2,fret:1},{string:3,fret:2},{string:4,fret:2},{string:5,fret:0}],
                G:  [{string:0,fret:3},{string:1,fret:0},{string:2,fret:0},{string:3,fret:0},{string:4,fret:2},{string:5,fret:3}],
                A:  [{string:0,fret:0},{string:1,fret:2},{string:2,fret:2},{string:3,fret:2},{string:4,fret:0}],
                Am: [{string:0,fret:0},{string:1,fret:1},{string:2,fret:2},{string:3,fret:2},{string:4,fret:0}],
                Dm: [{string:0,fret:1},{string:1,fret:3},{string:2,fret:2},{string:3,fret:0}],
                Em: [{string:0,fret:0},{string:1,fret:0},{string:2,fret:0},{string:3,fret:2},{string:4,fret:2},{string:5,fret:0}],
                // 7th chords for chromatic mode
                A7: [{string:0,fret:0},{string:1,fret:2},{string:2,fret:0},{string:3,fret:2},{string:4,fret:0}],
                B7: [{string:0,fret:2},{string:1,fret:0},{string:2,fret:2},{string:3,fret:1},{string:4,fret:2}],
                D7: [{string:0,fret:2},{string:1,fret:1},{string:2,fret:2},{string:3,fret:0}],
                E7: [{string:0,fret:0},{string:1,fret:0},{string:2,fret:1},{string:3,fret:0},{string:4,fret:2},{string:5,fret:0}],
                G7: [{string:0,fret:1},{string:1,fret:0},{string:2,fret:0},{string:3,fret:0},{string:4,fret:2},{string:5,fret:3}],
                F:  [{string:0,fret:1},{string:1,fret:1},{string:2,fret:2},{string:3,fret:3},{string:4,fret:3},{string:5,fret:1}],
                Bm: [{string:0,fret:2},{string:1,fret:3},{string:2,fret:4},{string:3,fret:4},{string:4,fret:2}],
            };

            // Melody notes that sound good over each chord (chord tones + passing tones)
            const MELODY = {
                C:  [{s:0,f:0},{s:0,f:3},{s:1,f:1},{s:1,f:0},{s:2,f:0}],
                D:  [{s:0,f:2},{s:0,f:5},{s:1,f:3},{s:1,f:0},{s:2,f:2}],
                E:  [{s:0,f:0},{s:0,f:4},{s:1,f:0},{s:1,f:5},{s:2,f:1}],
                G:  [{s:0,f:3},{s:0,f:0},{s:1,f:0},{s:1,f:3},{s:2,f:0}],
                A:  [{s:0,f:0},{s:0,f:5},{s:1,f:2},{s:1,f:5},{s:2,f:2}],
                Am: [{s:0,f:0},{s:0,f:5},{s:1,f:1},{s:1,f:5},{s:2,f:2}],
                Dm: [{s:0,f:1},{s:0,f:5},{s:1,f:3},{s:1,f:6},{s:2,f:2}],
                Em: [{s:0,f:0},{s:0,f:3},{s:1,f:0},{s:1,f:3},{s:2,f:0}],
                // 7th chord melodies (include the 7th)
                A7: [{s:0,f:0},{s:0,f:3},{s:1,f:2},{s:2,f:0},{s:2,f:2}],
                B7: [{s:0,f:2},{s:0,f:0},{s:1,f:0},{s:2,f:2},{s:1,f:4}],
                D7: [{s:0,f:2},{s:0,f:5},{s:1,f:1},{s:1,f:3},{s:2,f:2}],
                E7: [{s:0,f:0},{s:0,f:3},{s:1,f:0},{s:2,f:1},{s:1,f:5}],
                G7: [{s:0,f:1},{s:0,f:3},{s:1,f:0},{s:2,f:0},{s:1,f:3}],
                F:  [{s:0,f:1},{s:0,f:5},{s:1,f:1},{s:2,f:2},{s:1,f:6}],
                Bm: [{s:0,f:2},{s:0,f:5},{s:1,f:3},{s:2,f:4},{s:1,f:0}],
            };

            // Keys with diatonic chord progressions (circle of fifths relationships)
            const KEYS_BASIC = {
                'C':  { chords: ['C', 'Am', 'Dm', 'G', 'Em'] },
                'G':  { chords: ['G', 'Em', 'Am', 'C', 'D'] },
                'D':  { chords: ['D', 'Em', 'G', 'A'] },
                'Am': { chords: ['Am', 'Dm', 'E', 'G', 'C'] },
                'Em': { chords: ['Em', 'Am', 'G', 'D', 'C'] },
            };

            // Chromatic keys with 7ths, secondary dominants, and more minors
            const KEYS_CHROMATIC = {
                'C':  { chords: ['C', 'Am', 'Dm', 'G7', 'Em', 'F', 'A7', 'D7'] },
                'G':  { chords: ['G', 'Em', 'Am', 'C', 'D7', 'Bm', 'E7', 'A7'] },
                'D':  { chords: ['D', 'Em', 'G', 'A7', 'Bm', 'E7', 'D7'] },
                'Am': { chords: ['Am', 'Dm', 'E7', 'G', 'C', 'F', 'B7', 'A7'] },
                'Em': { chords: ['Em', 'Am', 'G', 'D', 'C', 'B7', 'A7', 'Bm'] },
            };

            const KEYS = chromaticEnabled ? KEYS_CHROMATIC : KEYS_BASIC;

            // Common chord progressions (indices into key's chord array)
            const PROGRESSIONS_BASIC = [
                [0, 1, 3, 2],       // I - vi - IV - ii (pop progression variant)
                [0, 3, 1, 2],       // I - IV - vi - ii
                [0, 2, 3, 0],       // I - ii - IV - I
                [0, 1, 2, 3],       // I - vi - ii - IV
                [0, 3, 0, 2],       // I - IV - I - ii
            ];

            // Chromatic progressions with secondary dominants and more movement
            const PROGRESSIONS_CHROMATIC = [
                [0, 6, 2, 3],       // I - V/ii - ii - V7 (secondary dominant to ii)
                [0, 5, 1, 3],       // I - IV - vi - V7
                [0, 1, 7, 3],       // I - vi - V/V - V7 (secondary dominant to V)
                [0, 4, 1, 3],       // I - iii - vi - V7
                [0, 2, 6, 3],       // I - ii - V/ii - V7
                [0, 5, 2, 3],       // I - IV - ii - V7
            ];

            const PROGRESSIONS = chromaticEnabled ? PROGRESSIONS_CHROMATIC : PROGRESSIONS_BASIC;

            // Pick random key and progression
            const keyNames = Object.keys(KEYS);
            const keyName = keyNames[Math.floor(Math.random() * keyNames.length)];
            const key = KEYS[keyName];
            const progression = PROGRESSIONS[Math.floor(Math.random() * PROGRESSIONS.length)];

            // Chord sustain pattern: 0 = none, 1 = root only, 2 = every other
            const sustainPattern = Math.floor(Math.random() * 3);

            // Chord rhythm: 2 = half notes (every 2 beats), 4 = whole notes (every 4 beats)
            const beatsPerChord = Math.random() < 0.5 ? 2 : 4;

            // Build the song: fill 32 beats with the progression
            const notes = [];
            const sustains = [];
            let position = 0;
            let chordCount = 0;

            while (position < 32) {
                const chordIdx = progression[chordCount % progression.length];
                const chordName = key.chords[chordIdx % key.chords.length];
                const chordNotes = CHORDS[chordName];
                const melodyNotes = MELODY[chordName];

                // Place chord on guitar 1 (staff 0)
                if (chordNotes) {
                    for (const note of chordNotes) {
                        notes.push({ staff: 0, string: note.string, position: position, fret: note.fret });
                    }
                    // Sustain based on pattern
                    const shouldSustain =
                        (sustainPattern === 1 && chordCount === 0) ||  // root only
                        (sustainPattern === 2 && chordCount % 2 === 0); // every other
                    if (shouldSustain) {
                        sustains.push({ staff: 0, position: position });
                    }
                }
                chordCount++;

                // Generate melody on guitar 2 (staff 1) - one note per beat
                let lastMelodyIdx = -1;
                for (let beat = 0; beat < beatsPerChord; beat++) {
                    // Pick a melody note, try to avoid immediate repetition
                    let melodyIdx;
                    do {
                        melodyIdx = Math.floor(Math.random() * melodyNotes.length);
                    } while (melodyIdx === lastMelodyIdx && melodyNotes.length > 1);
                    lastMelodyIdx = melodyIdx;

                    const tone = melodyNotes[melodyIdx];
                    notes.push({ staff: 1, string: tone.s, position: position + beat, fret: tone.f });

                    // Sustain some notes for legato feel
                    if (Math.random() < 0.25) {
                        sustains.push({ staff: 1, position: position + beat });
                    }
                }

                position += beatsPerChord;
            }

            // Clear and load the generated song
            clearTab();

            // Place notes on the grid
            for (const n of notes) {
                const note = getNoteElement(n.staff, n.string, n.position);
                if (note) note.textContent = n.fret;
            }

            // Set sustains
            for (const s of sustains) {
                if (s.staff < NUM_STAFFS && s.position < NUM_POSITIONS) {
                    sustainState[s.staff][s.position] = true;
                    const toggle = document.querySelector(`.sustain-toggle[data-staff="${s.staff}"][data-position="${s.position}"]`);
                    if (toggle) toggle.classList.add('active');
                }
            }

            // Save to URL
            saveStateToUrl();
        }

        function loadSampleSong(hash) {
            if (!hash) return;

            // Clear current state
            clearTab();

            // Load the song from hash
            window.location.hash = hash;
            loadStateFromUrl();

            // Reset dropdown
            document.getElementById('sampleSongs').value = '';
        }

        // Initialize on load
        initStaffs();
        initSampleSongs();
        loadStateFromUrl();
    </script>
</body>
</html>
